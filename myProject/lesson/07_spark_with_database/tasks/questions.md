### 1. Зачем придумали JDBC?

- [ ] Протокол предоставляет более эффективный доступ к БД, чем специальная библиотека.
- [x] Для предоставления универсального интерфейса.
- [x] Так легче поменять одну БД, с которой работает программа, на другую.
- [x] Единая абстракция упрощает разработку библиотек-оберток вокруг JDBC.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Протокол предоставляет более эффективный доступ к БД, чем специальная библиотека.
    - JDBC сам по себе является обычной абстракцией. Так что ускорения здесь не будет.
- [x] Для предоставления универсального интерфейса.
    - Верно! Так легче писать код.
- [x] Так легче поменять одну БД, с которой работает программа, на другую.
    - Точно! Можно поменять одну реализацию в JDBC на другую, но без необходимости переписывать код.
- [x] Единая абстракция упрощает разработку библиотек-оберток вокруг JDBC.
    - Правильно! Тот же JDBI, что мы разбирали в модуле, оборачивает JDBC, но не завязывается на
      конкретных провайдерах (PostgreSQL/MySQl/Oracle и так далее).

</details> 

### 2. Для чего нужны инструменты миграции?

- [x] Для автоматизации DDL-операций (`CREATE/ALTER/DROP`).
- [ ] Для автоматизации DML-операций (`SELECT/UPDATE/DELETE/INSERT`).
- [x] Для оптимизации работы программиста.
- [x] Проще разворачивать сервис на разных средах.

<details>
<summary>Пояснение к ответу</summary>

- [x] Для автоматизации DDL-операций (`CREATE/ALTER/DROP`).
    - Правильно! Чтобы не создавать каждый раз новые таблицы вручную, можем воспользоваться
      инструментом миграций, который будет запускаться автоматически.
- [ ] Для автоматизации DML-операций (`SELECT/UPDATE/DELETE/INSERT`).
    - Неверно. DML-операции выполняются при работе самого приложения. Их не нужно дополнительно
      автоматизировать.
- [x] Для оптимизации работы программиста.
    - Точно! Благодаря миграциям все таблицы создаются автоматически как в тестах, так и при
      запуске приложения на любой среде.
- [x] Проще разворачивать сервис на разных средах.
    - Конечно! Вам не нужно беспокоиться о предварительном создании таблиц при деплое на среду:
      инструмент миграции сделает это автоматически.

</details> 

### 3. Зачем использовать конфиги?

- [ ] Это дело вкуса, можно их не внедрять.
- [x] Чтобы разворачивать сервис на разных средах без повторной сборки проекта.
- [x] Чтобы не "светить" паролями к БД в коде.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Это дело вкуса, можно их не внедрять.
    - Неверно. Конфиги - важная часть любого приложения и обойти их не получится.
- [x] Чтобы разворачивать сервис на разных средах без повторной сборки проекта.
    - Правильно! В коде мы не используем значения для подключения к внешним сервисам напрямую.
      Поэтому у нас есть возможность собрать проект один раз и деплоить его везде, перопределяя лишь
      конфиги.
- [x] Чтобы не "светить" паролями к БД в коде.
    - Верно подмечено! Если вы "хардкодите" значения в коде, то не только уменьшаете его гибкость,
      но и делаете менее безопасным. Например, злоумышленник может увидеть данные подключения к БД в
      истории Git и воспользоваться ими.

</details> 

### 4. Почему для тестирования БД мы используем Testcontainers/H2, а не моки/стабы, как раньше?

- [x] Сложно предугадать заранее, что ответит БД, пока не выполнишь запрос.
- [ ] Потому что эти тесты работают быстрее.
- [ ] Такие тесты проще написать.
- [x] Моками/стабами не получится отловить ошибку в запросе.
- [x] Сложно протестировать валидность транзакционных сценариев.

<details>
<summary>Пояснение к ответу</summary>

- [x] Сложно предугадать заранее, что ответит БД, пока не выполнишь запрос.
    - Верно! В данном случае моки и стабы будут самообманом, потому что мы можем настроить их так,
      что они всегда будут отвечать положительно.
- [ ] Потому что эти тесты работают быстрее.
    - Неверно. Тесты с применением H2 или Testcontainers работают медленнее.
- [ ] Такие тесты проще написать.
    - Неверно. Интеграционные тесты намного сложнее в составлении и поддержке. Как минимум потому
      что используется общий ресурс - БД. Всегда есть риск того, что тесты начнут зависеть друг от
      друга.
- [x] Моками/стабами не получится отловить ошибку в запросе.
    - Конечно! Если у вас ошибка в самом запросе, вы не сможете ее протестировать моками.
- [x] Сложно протестировать валидность транзакционных сценариев.
    - Правильно! Транзакционность сложно протестировать на обычной stub-реализации.

</details> 

### 5. Выберите верные утверждения про блокировки.

- [x] Pessimistic Locking дает эксклюзивный lock на строчку(и) в БД до конца жизни транзакции.
- [ ] Optimistic Locking дает эксклюзивный lock на строчку(и) в БД до конца жизни транзакции.
- [ ] Pessimistic Locking проверяет соответствие версий перед коммитом и при ошибке
  вызывает `rollback`.
- [x] Optimistic Locking проверяет соответствие версий перед коммитом и при ошибке
  вызывает `rollback`.
- [ ] Pessimistic Locking можно реализовать, выставив уровень изоляции `REPEATABLE READ`.
- [x] Optimistic Locking можно реализовать, выставив уровень изоляции `REPEATABLE READ`.

<details>
<summary>Пояснение к ответу</summary>

- [x] Pessimistic Locking дает эксклюзивный lock на строчку(и) в БД до конца жизни транзакции.
    - Верно!
- [ ] Optimistic Locking дает эксклюзивный lock на строчку(и) в БД до конца жизни транзакции.
    - Неверно. Такое поведение характерно для Pessimistic Locking.
- [ ] Pessimistic Locking проверяет соответствие версий перед коммитом и при ошибке
  вызывает `rollback`.
    - Неверно. Такое поведение характерно для Optimistic Locking.
- [x] Optimistic Locking проверяет соответствие версий перед коммитом и при ошибке
  вызывает `rollback`.
    - Верно!
- [ ] Pessimistic Locking можно реализовать, выставив уровень изоляции `REPEATABLE READ`.
    - Неверно. Так можно реализовать Optimistic Locking.
- [x] Optimistic Locking можно реализовать, выставив уровень изоляции `REPEATABLE READ`.
    - Верно!

</details> 