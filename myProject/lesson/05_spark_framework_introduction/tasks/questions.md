### 1. Зачем нужен протокол HTTP?

- [x] Для передачи данных между клиентом и сервером по сети.
- [ ] Для удаленного вызова функций на приложении Java, которое запущено на другом физическом
  сервере.
- [x] Для абстрагирования реализаций клиента и сервера (они могут быть написаны на разных языках).

<details>
<summary>Пояснение к ответу</summary>

- [x] Для передачи данных между клиентом и сервером по сети.
    - Верно! Главная роль HTTP - передать информацию от клиента к серверу по сети.
- [ ] Для удаленного вызова функций на приложении Java, которое запущено на другом физическом
  сервере.
    - Протокол HTTP не предполагает вызов каких-либо функций на стороне сам по себе. Он лишь
      отправляет запрос, который сервер обрабатывает по своему усмотрению.
- [x] Для абстрагирования реализаций клиента и сервера (они могут быть написаны на разных языках).
    - Точно! В HTTP клиент и сервер могут быть написаны на любых языках и фреймворках. Протокол в
      этом случае выступает контрактом взаимодействия.

</details> 

### 2. Зачем нужен Spark Framework, если можно самому открыть socket в Java-приложении?

- [ ] Spark Framework будет гарантированно обладать лучшей производительностью.
- [x] Увеличивает скорость разработки.
- [x] Код становится проще.
- [x] Легче тестировать.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Spark Framework будет гарантированно обладать лучшей производительностью.
    - В Spark Framework нет никакой магии: в конечном счете где-то внутри будет создан socket. Так
      что производительность не будет гарантированно лучше.
- [x] Увеличивает скорость разработки.
    - Верно! Любой фреймворк (или библиотеке) призван ускорить разработку, чтобы сконцентрироваться
      на бизнес-логике, а не реализовывать инфраструктурные части самостоятельно.
- [x] Код становится проще.
    - Точно! Благодаря использованию фреймворка кода становится меньше и он выглядит
      более [декларативным](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). 
      Следовательно, его проще читать и воспринимать.
- [x] Легче тестировать.
    - Верно! Если вы пишете HTTP-сервер на Java с нуля, вам нужно убедиться не только в корректной
      работе бизнес-логики, но и получении HTTP-запроса. Так что тестов станет гораздо больше.

</details> 

### 3. Выберите все endpoint-ы, объявление которых правильно с точки зрения философии RESTful.

- [x] `POST /api/books`
- [ ] `POST /api/books/123`
- [ ] `DELETE /api/books/remove/123`
- [ ] `GET /api/create/books`
- [x] `GET /api/books/5`
- [ ] `PUT /api/books`
- [x] `PUT /api/books/56`
- [x] `DELETE /api/books/56`
- [ ] `DELETE /api/books`

<details>
<summary>Пояснение к ответу</summary>

- [x] `POST /api/books`
    - Верно! Тут мы хотим создать новую книгу.
- [ ] `POST /api/books/123`.
    - Неверно. Метод `POST` предполагает создание новой сущности, но мы уже указали конкретный ID в
      пути.
- [ ] `DELETE /api/books/remove/123`.
    - Неверно. В пути есть глагол `remove`, который дублирует суть метода `DELETE`.
- [ ] `GET /api/create/books`
    - Неверно. В пути есть глагол `delete`, который не только излишен, но и противоречит типу
      метода `GET`.
- [x] `GET /api/books/5`
    - Верно! Здесь мы запрашиваем книгу с id = 5.
- [ ] `PUT /api/books`
    - Неверно. Метод `PUT` выполняет редактирование сущности на сервере, но ее ID не указан в пути.
      Так что не ясно, чего ожидать от этой операции.
- [x] `PUT /api/books/56`
    - Верно! Здесь мы хотим отредактировать книгу с id = 56.
- [x] `DELETE /api/books/34`
    - Верно! Мы удаляем книгу с id = 34.
- [x] `DELETE /api/books`
    - Верно! Тут мы удаляем все книги. Хотя операции массового удаления редко применяются в реальной
      жизни, они корректны по RESTful.

</details>

### 4. Правда ли, что при отправке HTTP-запроса тело, если оно присутствует, должно быть строго в формате JSON?

- [ ] Да, протокол HTTP регламентирует, что тело должно быть только в формате JSON.
- [x] Нет, тело может быть в другом формате.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Да, протокол HTTP регламентирует, что тело должно быть только в формате JSON.
    - Неверно. В протоколе HTTP нет таких ограничений. Более того,
      устанавливая [заголовок `Content-Type`](https://linuxhint.com/possible-values-for-http-content-type-header/)
      в правильное значение, можно отправлять не только текст, но даже аудио, видео и изображения.
- [x] Нет, тело может быть в другом формате.
    - Верно! В протоколе HTTP нет таких ограничений. Более того,
      устанавливая [заголовок `Content-Type`](https://linuxhint.com/possible-values-for-http-content-type-header/)
      в правильное значение, можно отправлять не только текст, но даже аудио, видео и изображения.

</details>

### 5. В Spark вы можете возвращать как JSON-ы в качестве ответа, так и готовые HTML-страницы. В чем отличия?

- [x] Если мы возвращаем JSON-ы, то приложение будет более независимым от типа клиента, который к
  нам обращается.
- [ ] Если мы возвращаем HTML, то приложение будет более независимым от типа клиента, который к нам
  обращается.
- [ ] Хоть при возвращении HTML, хоть при возращении JSON наш клиент может быть любым.
- [x] Если мы хотим показывать результат обращения к серверу в браузере, реализация с возращением
  HTML потребует меньше ресурсов.

<details>
<summary>Пояснение к ответу</summary>

- [x] Если мы возвращаем JSON-ы, то приложение будет более независимым от типа клиента, который к
  нам обращается.
    - Верно! JSON - это универсальный формат разметки данных. Так что любой клиент сможет с ним
      работать (приложение на Javascript, терминал Linux, другой backend).
- [ ] Если мы возвращаем HTML, то приложение будет более независимым от типа клиента, который к нам
  обращается.
    - Неверно. В этом случае браузеру будет легче, потому что контент автоматически отобразиться для
      пользователя. Но если, например, вы выполняете HTTP-запрос из терминала Linux, то вам придется
      парсить не JSON, а HTML.
- [ ] Хоть при возвращении HTML, хоть при возращении JSON наш клиент может быть любым.
    - Неверно. Если мы возвращаем JSON, то клиент может любым. HTML подходит только для браузера.
- [x] Если мы хотим показывать результат обращения к серверу в браузере, реализация с возращением
  HTML потребует меньше ресурсов.
    - Верно! Если ваша цель - показать результат обращения к серверу в браузере, то сразу возращать
      HTML - самый простой вариант. В случае же JSON вам придется писать еще Single Page
      Application на React/Angular/VueJS, чтобы преобразовать JSON-ответ в разметку HTML.

</details>

### 6. Зачем нужно логирование в Java?

- [x] Фиксация информации о жизненном цикле приложения.
- [x] Упрощение при нахождении багов.

<details>
<summary>Пояснение к ответу</summary>

- [x] Фиксация информации о жизненном цикле приложения.
    - Верно! Так мы сможем понять, что и в какой момент времени выполняло наше приложение.
- [x] Упрощение при нахождении багов.
    - Точно! Если возникнет какая-то неожиданная ошибка, логи помогут нам установить причины,
      которые к ней привели.

</details>

### 7. Почему вместо логирования не использовать System.out.println?

- [ ] Эти варианты взаимозаменяемы.
- [ ] Логирование работает быстрее.
- [x] Логер позволяет абстрагировать фиксацию события и его вывод. 
  Проще говоря, логер - это абстракция для вывода сообщений (в файл/консоль).
- [x] С помощью инфраструктуры логирования можно настраивать правила выведения сообщений для
  библиотек и фреймворков, которые мы добавляем к себе в проект.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Эти варианты взаимозаменяемы.
    - Неверно. У них есть важные отличия. Если для вас это не очевидно, перечитайте урок по
      логированию в текущем модуле.
- [ ] Логирование работает быстрее.
    - Необязательно. Если вы хотите вывести сообщения в консоль, то где-то под капотом все равно
      будет вызов `println`. Так что однозначного выигрыша в производительности здесь нет.
- [x] Логер позволяет абстрагировать фиксацию события и его вывод.
  Проще говоря, логер - это абстракция для вывода сообщений (в файл/консоль).
    - Абсолютно верно! Если мы используем логер, то нам достаточно лишь отредактировать
      конфигурационный файл, чтобы настроить вывод логов для того или иного класса.
- [x] С помощью инфраструктуры логирования можно настраивать правила выведения сообщений для
  библиотек и фреймворков, которые мы добавляем к себе в проект.
    - Верно! Логирование позволяет настраивать вывод даже для того кода, который мы сами не писали.

</details>

### 8. Можно ли конкатенировать строки в логере?

- [ ] Да, в этом нет ничего плохого.
- [x] Нет, не стоит.

<details>
<summary>Пояснение к ответу</summary>

- [ ] Да, в этом нет ничего плохого.
    - Неверно. При конкатенации создается новая строка. Так что каждый раз, когда будет доходить до
      нужной строчки, будет создаваться строка, даже если логер для данного класса выключен (или его
      уровень слишком высокий). Это может привести к проблемам с производительностью.
- [x] Нет, не стоит.
    - Верно! При конкатенации создается новая строка. Так что каждый раз, когда будет доходить до
      нужной строчки, будет создаваться строка, даже если логер для данного класса выключен (или его
      уровень слишком высокий). Это может привести к проблемам с производительностью.

</details>
